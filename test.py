import threading
import random
import networkx as nx
import matplotlib.pyplot as plt

class Task:
    name = ""
    reads = []
    writes = []
    run = None
    executed_parallel = False

# Variables globales utilisées pour la communication entre les tâches
X = None  # Variable partagée entre les tâches
Y = None  # Variable partagée entre les tâches
Z = None  # Variable partagée entre les tâches

# Fonctions associées pour chaque tâche
def runT1():
    global X
    X = 1

def runT2():
    global Y
    Y = 2

def runT3():
    global X, Y, Z
    Z = X + Y

class TaskSystem:
    compteur = 1
    def __init__(self,tasks=[],previous={}):
        self.listTask = tasks
        self.previousTask = previous

#----------------------------------------------------------------
    def getDependencies(self, nomTache): # liste des dépendances de tâches
        dependencies = [] # liste vide
        for taskName, precedenceList in self.previousTask.items(): # on récupère les tâches précédentes dans "previousTask" pour chaque tâche
            if nomTache == taskName:
                print(f"Les dépendances de tâches {nomTache} sont:")
                dependencies.extend(precedenceList) # on ajoute les dépendances à la liste
        return dependencies # on a l'entièreté des dépendances pour chaque tâche
    
    """def getDependencies(self):
        dependencies = [] # liste dépendances
        for task1 in self.listTask:
                for task2 in self.listTask:
                    if task1 != task2:
                        if not self.checkBernstein(task1, task2):
                            print("dep")
                            dependencies.extend(task2.name)
        return dependencies"""

#----------------------------------------------------------------
    def runSeq(self):
        executedTask = [] # liste des tâches déjà excutées 
        while len(executedTask) < len(self.listTask): # tant qu'il a moins de tâches excutées que de tâches à executer
                for task in self.listTask:
                    if task.name not in executedTask: # tâches non executées
                        dependencies = self.getDependencies(task.name) # tâches à faire avant car dépendance
                        hasDep = True # la tâche dépend d'une autre tâche
                        if dependencies:
                            for dep in dependencies:
                                if dep not in executedTask:
                                    hasDep = False
                                    break
                        if hasDep:
                            task.run() # exécuter la tâche
                            print(f"La tâche '{task.name}' est exécutée")
                            executedTask.append(task.name) # ajouter la tâche à la liste des tâches exécutées
                        else:
                            print(f"La tâche '{task.name}' ne peut pas être exécutée car les dépendances ne sont pas satisfaites.")
                            continue  # Passe à la prochaine itération de la boucle for, permet d'executer les tâches pouvant l'être afin "d'éliminer" des dépendances
    
#----------------------------------------------------------------
    def checkBernstein(self, task1, task2):
        """
        Vérifie si la condition de Bernstein est satisfaite entre deux tâches.
        Retourne True si les tâches peuvent être exécutées en parallèle, False sinon.
        """
        # Condition de Bernstein
        if any(n in task1.reads for n in task2.writes):
            return False  
        elif any(n in task2.reads for n in task1.writes):
            return False  
        elif any(n in task1.writes for n in task2.writes):
            return False  
        else:
            return True 

#----------------------------------------------------------------
    def cleanGroups(self, groups):
        cleaned_groups = []

        # Parcourir les groupes
        for group in groups:
            is_subset = False
            # Vérifier si le groupe est un sous-ensemble d'un autre groupe
            for other_group in groups:
                if group != other_group and set(group).issubset(set(other_group)):
                    is_subset = True
                    break
            # Si le groupe n'est pas un sous-ensemble d'un autre groupe, l'ajouter aux groupes nettoyés
            if not is_subset:
                cleaned_groups.append(group)

        return cleaned_groups

#----------------------------------------------------------------
    def run(self):
        groups = []
        n = len(self.listTask)
        for i in range(n):
            for j in range(i+1, n):
                task1 = self.listTask[i]
                task2 = self.listTask[j]
                if self.checkBernstein(task1, task2):
                    # Créer un nouveau groupe avec les deux tâches
                    new_group = [task1.name, task2.name]
                    for k in range(j+1, n):
                        task3 = self.listTask[k]
                        # Vérifier si la troisième tâche peut être ajoutée au groupe existant
                        if all(self.checkBernstein(self.listTask[index], task3) for index in range(len(new_group))):
                            new_group.append(task3.name)
                    # Ajouter le groupe à la liste des groupes
                    groups.append(new_group)
                    
        # Nettoyer les groupes
        cleaned_groups = self.cleanGroups(groups)

        # Affichage des groupes de tâches parallèles
        print("Groupes de tâches parallèles:")
        for i, group in enumerate(cleaned_groups, 1):
            print(f"Groupe {i}: {group}")

        # Exécuter les tâches en parallèle selon les conditions spécifiées
        if len(cleaned_groups) == 1:
            chosen_group = cleaned_groups[0]
        elif len(cleaned_groups) > 1:
            chosen_group = random.choice(cleaned_groups)
        else:
            print("Impossible de trouver des tâches pouvant être exécutées simultanément.")
            return False

        threads = []

        # Exécuter les tâches du groupe choisi en parallèle
        print("\nExécution des tâches en parallèle:")
        for task_name in chosen_group:
            task = next(task for task in self.listTask if task.name == task_name)
            task.executed_parallel = True 
            thread = threading.Thread(target=self.executedTask, args=(task,))
            threads.append(thread)
            thread.start()
        
        # Attendre que tous les threads se terminent (si on veux exécuter beaucoup de thread)
        for thread in threads:
            thread.join()
        
        return any(thread.is_alive() == False for thread in threads)

#----------------------------------------------------------------
    def executedTask(self, task):
        task.run()
        print(f"La tâche '{task.name}' est exécutée")

#---------------------------------------------------------------
    def detTestRnd(self):
        """
        Méthode pour tester le déterminisme en exécutant deux fois le système avec les mêmes valeurs aléatoires.
        """
        # Exécuter le système de tâches pour capturer les variables utilisées après l'exécution
        ExecuteParallel = self.run()

        if not ExecuteParallel:
            return False
        else:
            # Obtenir les noms des variables des tâches exécutées en parallèle
            global_vars_names = set()

            for task in self.listTask:
                if task.executed_parallel:
                    global_vars_names.update(task.writes)

            global_vars_names = list(global_vars_names)

            # Générer des valeurs aléatoires pour les variables globales
            random_values = [random.randint(0, 100) for _ in range(len(global_vars_names))]

            # Réinitialiser les variables globales avec les valeurs aléatoires générées
            for var_name, var_value in zip(global_vars_names, random_values):
                globals()[var_name] = var_value

            # Exécuter le système de tâches pour la première fois
            print("Première exécution du système :")
            self.run()
            print("Résultat de la première exécution :", end=" ")
            for var_name, var_value in zip(global_vars_names, random_values):
                print(f"{var_name} =", var_value, ",", end=" ")
            print("\nFin de la première exécution\n")
            result_1 = random_values[:]
            executed_tasks = [task.name for task in self.listTask if task.executed_parallel]
            for task in self.listTask:
                if task.name not in executed_tasks:
                    dependencies = self.getDependencies(task.name)
                    has_dep = any(dep in executed_tasks for dep in dependencies)
                    if not has_dep:
                        task.run()
                        print(f"La tâche '{task.name}' est exécutée après les tâches en parallèle. Résultat :")
                        for var_name in task.writes:
                            print(f"{var_name} =", globals()[var_name])

            # Réinitialiser les variables globales avec les mêmes valeurs aléatoires pour la deuxième exécution
            for var_name, var_value in zip(global_vars_names, random_values):
                globals()[var_name] = var_value

            # Exécuter le système de tâches pour la deuxième fois
            print("Deuxième exécution du système :")
            self.run()  # Pas besoin d'appeler self.run() ici
            print("Résultat de la deuxième exécution :", end=" ")
            for var_name, var_value in zip(global_vars_names, random_values):
                print(f"{var_name} =", var_value, ",", end=" ")
            print("\nFin de la deuxième exécution\n")
            result_2 = random_values[:]
            executed_tasks = [task.name for task in self.listTask if task.executed_parallel]
            for task in self.listTask:
                if task.name not in executed_tasks:
                    dependencies = self.getDependencies(task.name)
                    has_dep = any(dep in executed_tasks for dep in dependencies)
                    if not has_dep:
                        task.run()
                        print(f"La tâche '{task.name}' est exécutée après les tâches en parallèle. Résultat :")
                        for var_name in task.writes:
                            print(f"{var_name} =", globals()[var_name])

            # Vérifier si les résultats de la première et de la deuxième exécution sont les mêmes
            if result_1 == result_2:
                print("Le système est déterministe.")
            else:
                print("Le système n'est pas déterministe.")
  #---------------------------------------------------------------  
t1 = Task()
t1.name = "T1"
t1.writes = ["X"]
t1.run = runT1

t2 = Task()
t2.name = "T2"
t2.writes = ["Y"]
t2.run = runT2

t3 = Task()
t3.name = "somme"
t3.reads = ["X", "Y"]
t3.writes = ["Z"]
t3.run = runT3

# Créer une dépendance cyclique entre T1 et T3
system = TaskSystem([t1, t2, t3], {
    "T1": [],
    "T2": [],
    "somme": ["T1", "T2"] 
})

system.detTestRnd()
