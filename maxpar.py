import threading

class Task:
    name = ""
    reads = []
    writes = []
    run = None

X = None
Y = None
Z = None

def runT1():
    global X
    X = 1

def runT2():
    global Y
    Y = 2

def runT3():
    global N
    N = 5

def runTsomme():
    global X, Y, Z
    Z = X + Y

t1 = Task()
t1.name = "T1"
t1.writes = ["X"]
t1.run = runT1

t2 = Task()
t2.name = "T2"
t2.writes = ["Y"]
t2.run = runT2

t3 = Task()
t3.name = "T3"
t3.writes = ["Y"]
t3.run = runT3

tSomme = Task()
tSomme.name = "somme"
tSomme.reads = ["X","Y"]
tSomme.writes = ["Z"]
tSomme.run = runTsomme

t1.run()
t2.run()
tSomme.run()
print(X)
print(Y)
print(Z)

class TaskSystem:
    def __init__(self,tasks=[],previous={}):
        self.listTask = tasks
        self.previousTask = previous

    def getDependencies(self, nomTache): # liste des dépendances de tâches
        dependencies = [] # liste vide
        for taskName, precedenceList in self.previousTask.items(): # on récupère les tâches précédentes dans "previousTask" pour chaque tâche
            if nomTache == taskName:
                dependencies.extend(precedenceList) # on ajoute les dépendances à la liste
        return dependencies # on a l'entièreté des dépendances pour chaque tâche
    
    def runSeq(self):
        executedTask = [] # liste des tâches déjà excutées 
        while len(executedTask) < len(self.listTask): # tant qu'il a moins de tâches excutées que de tâches à executer
                for task in self.listTask:
                    if task.name not in executedTask: # tâches non executées
                        dependencies = self.getDependencies(task.name) # tâches à faire avant car dépendance
                        hasDep = True # la tâche dépend d'une autre tâche
                        if dependencies:
                            for dep in dependencies:
                                if dep not in executedTask:
                                    hasDep = False
                                    break
                        if hasDep:
                            task.run() # exécuter la tâche
                            print(f"La tâche '{task.name}' est exécutée")
                            executedTask.append(task.name) # ajouter la tâche à la liste des tâches exécutées
                        else:
                            print(f"La tâche '{task.name}' ne peut pas être exécutée car les dépendances ne sont pas satisfaites.")
                            continue  # Passe à la prochaine itération de la boucle for, permet d'executer les tâches pouvant l'être afin "d'éliminer" des dépendances
    
    def run(self): # paralleliser les tâches
        tasksToExecute = set()
        for task1 in self.listTask:
            for task2 in self.listTask:
                if task1 != task2:
                    # Utilisation de la condition de Bernstein
                    if any(n in task1.reads for n in task2.writes):
                        print(f"'{task1.name}' lit ce que '{task2.name}' écrit")
                        break
                    elif any(n in task2.reads for n in task1.writes):
                        print(f"'{task2.name}' lit ce que '{task1.name}' écrit")
                        break
                    elif any(n in task1.writes for n in task2.writes):
                        print(f"'{task1.name}' écrit au même endroit que '{task2.name}'")
                        break
                    else:
                        print(f" La condition de Bernstein est validée, '{task1.name}' et '{task2.name}' peuvent être parallélisées")
                        tasksToExecute.add(task1)
                        break 
        if tasksToExecute:
            for task in tasksToExecute:
                task.run()
                print(f"La tâche '{task.name}' est exécutée")
        else:
            print("Impossible de trouver des tâches pouvant être exécutées simultanément.")

                
##########################################  J'espère que j'ai pas écrit nimp :')
    def rightEntry(self):
        for task in self.listTask: # vérifier que le nom de tâche n'est pas déjà utilisé
            if self.t.name == task.name :
                print(f"La tâche '{task.name}' existe déjà")
                break
            else:
                self.listTask.add(self.t)
                
        for task in self.getDependencies: # vérifier que la tâche dans getDependencies existe réellement
            for self.t in self.listTask:
                if self.t == task:
                    print(f"'{task.name}' existe bel et bien")
                    break
                else:
                    print(f"'{task.name}' n'existe pas, la dépendance est donc fausse")
                    self.getDependencies.remove(task)
                    
        """ pour determinisme, vérifier :
        tâches sans domaine d'écriture ? -> pas de pb
        écriture et lecture d'éléments différents ? -> pas de pb
        condition de Bernstein
        \_ vérifier que pas de différence lors de parallélisation (A puis B = X ET B puis A = X)"""
        
        for task in self.listTask:
            if task.writes == []:
                print("Le système est déterministe")
                break
            # if condition de Bernstein sur la liste des tâches en parallèle est vraie:
                # print("Le système est déterministe")
                # break
            # else: 
                # print("Le système n'est déterministe")
        
#############################################

s1 = TaskSystem([t1,t2,t3,tSomme], {"T1": [], "T2": ["T3"], "T3": [], "somme":["T1","T2"]})

print(s1.getDependencies("somme"))
print('run:')
s1.run()
print('runSeq:')
s1.runSeq()


'''
def rightEntry(self):
    # Vérification des noms de tâches uniques
    task_names = set()
    for task in self.listTask:
        if task.name in task_names:
            print(f"Erreur: Le nom de tâche '{task.name}' est dupliqué.")
            return False
        task_names.add(task.name)

    # Vérification de l'existence des tâches dans les dépendances
    for dependencies in self.previousTask.values():
        for dependency in dependencies:
            if dependency not in task_names:
                print(f"Erreur: La tâche '{dependency}' dans les dépendances n'existe pas.")
                return False

    # Vérification de l'existence des tâches référencées dans getDependencies
    for task_name in task_names:
        if task_name not in self.previousTask:
            print(f"Erreur: La tâche '{task_name}' dans getDependencies n'a pas été définie.")
            return False

    # Autres vérifications pour le déterminisme

    return True
'''