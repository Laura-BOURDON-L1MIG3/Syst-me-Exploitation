class Task:
    name = ""
    reads = []
    writes = []
    run = None

X = None
Y = None
Z = None

def runT1():
    global X
    X = 1

def runT2():
    global Y
    Y = 2

def runTsomme():
    global X, Y, Z
    Z = X + Y

t1 = Task()
t1.name = "T1"
t1.writes = ["X"]
t1.run = runT1

t2 = Task()
t2.name = "T2"
t2.writes = ["Y"]
t2.run = runT2

tSomme = Task()
tSomme.name = "somme"
tSomme.reads = ["X", "Y"]
tSomme.writes = ["Z"]
tSomme.run = runTsomme

t1.run()
t2.run()
tSomme.run()
print(X)
print(Y)
print(Z)

class TaskSystem:
    """
    listTask = []  #objet de la classe Task
    previousTask = {}   #les clés sont les noms des tâches et les valeurs sont les listes des noms des tâches qui doivent être exécutées avant la tâche correspondante
    on déclare directement dans def __init__
    """ 

    #il faut avoir un __init__() Function
    def __init__(self,tasks=[],previous={}):
        self.listTask = tasks
        self.previousTask = previous

    #initialiser une liste dependencies pour retourner les tâches qui doivent s’exécuter avant la tâche nomTache
    #vérifiez les clés (noms de tâches) et les valeurs (listes de dépendances) du dictionnaire par méthode items()
    def getDependencies(self, nomTache):
        dependencies = []
        for taskName, precedenceList in self.previousTask.items():
            if nomTache == taskName:
                dependencies.extend(precedenceList)
        return dependencies

    """
    Objectif: Effectuer les tâches séquentielle tout en utilisant condition de Bernstein
    condition de Bernstein: Deux tâches ne peuvent pas être exécutées en parallèle si l'une d'elles écrit une donnée que l'autre lit
    idée: vérifier les dépendances, si vrai, on execute, sinon, on n'execute pas les tâches
    """
    def runSeq(self):
        executedTask = set()
        while len(executedTask) < len(self.listTask):
            for task in self.listTask:
                if task.name not in executedTask:
                    dependencies = self.getDependencies(task.name)
                    if dependencies and not all(dep in executedTask for dep in dependencies):
                        print(f"La tâche '{task.name}' ne peut pas être exécutée car les dépendances ne sont pas satisfaites.")
                        continue 
                    task.run()
                    print(f"La tâche '{task.name}' est exécutée")
                    executedTask.add(task.name)

    """
    def run():
        print("Lancement fonction run")
        # si une tache a pas besoin d'une autre avant alors la faire => les faire toutes les tâches précédentes
        # previousTask = 0 
        # for task in listTask :
            # if getDependencies(nomTache) != 0 alors on doit executer les autres taches avant
            # est ce qu'on peut savoir cmb de temps dure une tache ? -> + courte en first ?
            # supprimer la tache de la liste pr ne pas pouvoir la relancer
            # calculer cmb max en mm temps et duree (comparer les grp de taches a executer)
    """
    def run(self):
        executedTask = set()
        while self.listTask:
            tasksToRemove = set()
            tasksToExecute = set()
            for task1 in self.listTask:
                canExecute = True
                for task2 in self.listTask:
                    if task1 != task2:
                        # Utilisation de la condition de Bernstein
                        if any(r in task2.writes for r in task1.reads) or any(r in task1.writes for r in task2.reads):
                            canExecute = False
                            break
                if canExecute:
                    tasksToExecute.add(task1)
                else:
                    tasksToRemove.add(task1)
            if tasksToExecute:
                for task in tasksToExecute:
                    task.run()
                    print(f"La tâche '{task.name}' est exécutée")
                    executedTask.add(task)
            else:
                print("Impossible de trouver des tâches pouvant être exécutées simultanément.")
                break
            for task in tasksToRemove:
                self.listTask.remove(task)


s1 = TaskSystem([t1,t2,tSomme], {"T1": [], "T2": ["T1"], "somme":["T1","T2"]})

print(s1.getDependencies("somme"))
s1.runSeq()
s1.run()