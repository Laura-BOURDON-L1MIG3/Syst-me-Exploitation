import threading
import random
import networkx as nx
import matplotlib.pyplot as plt

class Task:
    name = ""
    reads = []
    writes = []
    run = None

# Variables globales utilisées pour la communication entre les tâches
X = None  # Variable partagée entre les tâches
Y = None  # Variable partagée entre les tâches
Z = None  # Variable partagée entre les tâches

# Fonctions associées pour chaque tâche
def runT1():
    global X
    X = 1

def runT2():
    global Y
    Y = 2

def runT3():
    global N
    N = 5

def runTsomme():
    global X, Y, Z
    Z = X + Y

class TaskSystem:
    compteur = 1
    def __init__(self,tasks=[],previous={}):
        self.listTask = tasks
        self.previousTask = previous

#----------------------------------------------------------------
    def getDependencies(self, nomTache): # liste des dépendances de tâches
        dependencies = [] # liste vide
        for taskName, precedenceList in self.previousTask.items(): # on récupère les tâches précédentes dans "previousTask" pour chaque tâche
            if nomTache == taskName:
                print(f"Les dépendances de tâches {nomTache} sont:")
                dependencies.extend(precedenceList) # on ajoute les dépendances à la liste
        return dependencies # on a l'entièreté des dépendances pour chaque tâche

#----------------------------------------------------------------
    def runSeq(self):
        executedTask = [] # liste des tâches déjà excutées 
        while len(executedTask) < len(self.listTask): # tant qu'il a moins de tâches excutées que de tâches à executer
                for task in self.listTask:
                    if task.name not in executedTask: # tâches non executées
                        dependencies = self.getDependencies(task.name) # tâches à faire avant car dépendance
                        hasDep = True # la tâche dépend d'une autre tâche
                        if dependencies:
                            for dep in dependencies:
                                if dep not in executedTask:
                                    hasDep = False
                                    break
                        if hasDep:
                            task.run() # exécuter la tâche
                            print(f"La tâche '{task.name}' est exécutée")
                            executedTask.append(task.name) # ajouter la tâche à la liste des tâches exécutées
                        else:
                            print(f"La tâche '{task.name}' ne peut pas être exécutée car les dépendances ne sont pas satisfaites.")
                            continue  # Passe à la prochaine itération de la boucle for, permet d'executer les tâches pouvant l'être afin "d'éliminer" des dépendances
    
#----------------------------------------------------------------
    def checkBernstein(self, task1, task2):
        """
        Vérifie si la condition de Bernstein est satisfaite entre deux tâches.
        Retourne True si les tâches peuvent être exécutées en parallèle, False sinon.
        """
        # Condition de Bernstein
        if any(n in task1.reads for n in task2.writes):
            return False  
        elif any(n in task2.reads for n in task1.writes):
            return False  
        elif any(n in task1.writes for n in task2.writes):
            return False  
        else:
            return True 

#----------------------------------------------------------------
    def cleanGroups(self, groups):
        cleaned_groups = []

        # Utiliser un ensemble pour stocker les groupes uniques
        unique_groups = set()

        for group in groups:
            if len(group) == 1:
                continue  # Ignorer les groupes contenant une seule tâche
            else:
                # Vérifier si toutes les paires de tâches dans le groupe satisfont à la condition de Bernstein
                violated = False
                for i in range(len(group)):
                    for j in range(i + 1, len(group)):
                        task1 = next(task for task in self.listTask if task.name == group[i])
                        task2 = next(task for task in self.listTask if task.name == group[j])
                        if not self.checkBernstein(task1, task2):
                            violated = True
                            break
                    if violated:
                        break

                # Si aucune paire de tâches ne viole la condition de Bernstein et que le groupe n'est pas déjà dans les groupes nettoyés, l'ajouter
                if not violated and group not in cleaned_groups:
                    unique_group = tuple(sorted(group))
                    unique_groups.add(unique_group)
        
        # Convertir les groupes uniques en liste de listes
        for unique_group in unique_groups:
            cleaned_groups.append(list(unique_group))

        return cleaned_groups

#----------------------------------------------------------------
    def run(self):
        groups = []
        for task1 in self.listTask:
            group = [task1.name]
            for task2 in self.listTask:
                if task1 != task2:
                    # Utilisation de la condition de Bernstein
                    if self.checkBernstein(task1, task2):
                        group.append(task2.name)
            # Ajouter le groupe formé à la liste des groupes
            groups.append(group)

        # Nettoyer les groupes
        cleaned_groups = self.cleanGroups(groups)

        # Affichage des groupes de tâches parallèles
        print("Groupes de tâches parallèles:")
        for i, group in enumerate(cleaned_groups, 1):
            print(f"Groupe {i}: {group}")

        # Étape 2: Exécuter les tâches en parallèle selon les conditions spécifiées
        if len(cleaned_groups) == 1:
            chosen_group = cleaned_groups[0]
        elif len(cleaned_groups) > 1:
            chosen_group = random.choice(cleaned_groups)
        else:
            print("Impossible de trouver des tâches pouvant être exécutées simultanément.")
            return

        threads = []

        # Exécuter les tâches du groupe choisi en parallèle
        print("\nExécution des tâches en parallèle:")
        for task_name in chosen_group:
            task = next(task for task in self.listTask if task.name == task_name)
            thread = threading.Thread(target=self.executedTask, args=(task,))
            threads.append(thread)
            thread.start()

        # Attendre que tous les threads se terminent
        for thread in threads:
            thread.join()

    def executedTask(self, task):
        task.run()
        print(f"La tâche '{task.name}' est exécutée")

                
#----------------------------------------------------------------
    def rightEntry(self):
        # vérifier que le nom de tâche n'est pas déjà utilisé
        taskNames = set()
        for task in self.listTask:
            if task.name in taskNames:
                print(f"Erreur: Le nom de tâche '{task.name}' existe déjà")
                return False
            taskNames.add(task.name)
                
        # vérifier que la tâche dans getDependencies existe réellement        
        for dependencies in self.previousTask.values():
            for dependency in dependencies:
                if dependency not in taskNames:
                    print(f"Erreur: La tâche '{dependency}' dans les dépendances n'existe pas.")
                    return False
                else:
                    print(f"'{dependency}' existe bel et bien")
                    break
        
        # Autres vérifications pour le déterminisme
        for task in self.listTask:
            # Vérification des tâches sans domaine d'écriture
            if not task.writes:
                print(f"Attention: La tâche '{task.name}' n'écrit sur aucun domaine.")

            # Vérification de la condition de Bernstein
            for other_task in self.listTask:
                if task != other_task:
                    if not self.checkBernstein(task, other_task):
                        print(f"Attention: La condition de Bernstein n'est pas satisfaite entre les tâches '{task.name}' et '{other_task.name}'.")

        print("Le système est déterministe")
        return True
        
#----------------------------------------------------------------
    def draw(self):
        # Création d'un graphe orienté
        G = nx.DiGraph()

        # Ajout des tâches en tant que nœuds dans le graphe
        for task in self.listTask:
            G.add_node(task.name)

        # Ajout des arêtes en fonction des précédences
        for parent_task, child_tasks in self.previousTask.items():
            for child_task in child_tasks:
                G.add_edge(child_task, parent_task)

        # Dessin du graphe
        figure_name = f"Figure {TaskSystem.compteur}"  # Modification du nom de la figure
        plt.figure(figure_name)
        nx.draw(G, with_labels=True, node_color='skyblue', node_size=1250, font_size=10, font_weight='bold', arrowsize=20, arrows=True)

        # Ajouter un titre au graphe
        plt.title(figure_name)

        # Affichage du graphe
        plt.show()
        
        # Incrémenter le compteur de figure
        TaskSystem.compteur += 1

#---------------------------------------------------------------
    def detTestRnd(self, num_tests=100):

        for i in range(num_tests):
            # Générer un jeu de valeurs aléatoires pour les variables partagées
            X = random.randint(0, 100)
            Y = random.randint(0, 100)
            Z = None  # Réinitialiser Z à None

            # Exécuter le système de tâches en parallèle
            self.run()

            # Stocker le résultat pour la première exécution
            result1 = Z

            # Réinitialiser les valeurs des variables partagées
            X = random.randint(0, 100)
            Y = random.randint(0, 100)
            Z = None  # Réinitialiser Z à None

            # Exécuter à nouveau le système de tâches en parallèle
            self.run()

            # Stocker le résultat pour la deuxième exécution
            result2 = Z

            # Comparer les résultats des deux exécutions
            if result1 != result2 or not self.checkBernstein():
                print("Le système n'est pas déterministe.")
                return False

        print("Le système est déterministe pour les jeux de valeurs aléatoires testés.")
        return True
    
        
###### C'EST PAS FINI DU TOUT !!! JE DOIS ME PREPARER PR LE BAD, JE FERAI LA SUITE APRES
    def parCost():
        tempsRunSeq = 0
        tempsRun = 0
        tabRun = set()
        tabRunSeq = set()
        for i in range(10):
            tempsRun = 2
            tabRun.add(tempsRun)
            tempsRunSeq = 3
            tabRunSeq.add(tempsRunSeq)
            for temps in tabRun:
                print("moyenne de temps de run() '{tempsRun}'")
            for temps in tabRunSeq:
                print("moyenne de temps de runSeq() '{tempsRunSeq}'")
            if(tempsRun>tempsRunSeq):
                print(f"différence : '{tempsRun - tempsRunSeq}' secondes")
            else:
                print(f"différence : '{tempsRunSeq - tempsRun}' secondes")
#########################################
