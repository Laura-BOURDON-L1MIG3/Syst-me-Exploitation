import threading
import random
import networkx as nx
import matplotlib.pyplot as plt
import time

class Task:
    name = ""
    reads = []
    writes = []
    run = None
    executed_parallel = False
    
class TaskSystem: # définition du sytème de tâches
    compteur = 1
    def __init__(self,tasks=[],previous={}):
        self.listTask = tasks
        self.previousTask = previous

#----------------------------------------------------------------
    def getDependencies(self, task1):
        dependencies = [] # liste dépendances
        if task1 in self.listTask:
                for task2 in self.listTask:
                    if task1.name != task2.name:
                        if not self.checkBernstein2(task1, task2): # Conditions pas respectées = dépendances
                            dependencies.append(task2.name) # On ajoute la tâche aux dépendances      
        return dependencies # Tableau des dépendances

#----------------------------------------------------------------
    def runSeq(self):
        executedTask = [] # liste des tâches déjà "excutées"
        while len(executedTask) < len(self.listTask): # le tableau ne contient pas encore toutes les tâches
                for task in self.listTask:
                    if task.name not in executedTask: # tâches "non executées"
                        dependencies = self.getDependencies(task) # tâches à faire avant car dépendance
                        hasDep = True # la tâche dépend d'une autre tâche
                        if dependencies:
                            for dep in dependencies:
                                if dep not in executedTask:
                                    hasDep = False
                                    break
                        if hasDep:
                            task.run() # exécuter la tâche
                            print(f"La tâche '{task.name}' est exécutée")
                            executedTask.append(task.name) # ajouter la tâche à la liste des tâches exécutées
                        else:
                            print(f"La tâche '{task.name}' ne peut pas être exécutée car les dépendances ne sont pas satisfaites.")
                            continue  # Passe à la prochaine itération de la boucle for, permet d'executer les tâches pouvant l'être afin "d'éliminer" des dépendances
    
#----------------------------------------------------------------
    def checkBernstein(self, task1, task2):
        
        """Vérifie si la condition de Bernstein est satisfaite entre deux tâches.
        Retourne True si les tâches peuvent être exécutées en parallèle, False sinon."""
        
        # Conditions de Bernstein
        if any(n in task1.reads for n in task2.writes): # t1 lis ce que t2 écrit
            return False  
        elif any(n in task2.reads for n in task1.writes): # t2 lis ce que t1 écrit
            return False  
        elif any(n in task1.writes for n in task2.writes): # t1 écrit au même endroit que t2
            return False  
        else:
            return True 

#----------------------------------------------------------------
    def checkBernstein2(self, task1, task2):
        
        """2/3 Conditions de Bernstein, "t2 lis ce que t1 écrit" 
        supprimé pour getDependencies car on ne veut se baser que sur t1"""
        
        if any(n in task1.reads for n in task2.writes): # t1 lis ce que t2 écrit
            return False  
        elif any(n in task1.writes for n in task2.writes): # t1 écrit au même endroit que t2
            return False  
        else:
            return True 

#----------------------------------------------------------------
    def verifyGroups(self, groups):
        verified_groups = []

        for group in groups: # Parcourir les différents groupes de tâches
            is_subset = False
            # Vérifier que le groupe n'est pas un sous-ensemble d'un autre groupe
            for other_group in groups:
                if group != other_group and set(group).issubset(set(other_group)):
                    is_subset = True
                    break
            # Si le groupe n'est pas un sous-ensemble d'un autre groupe, l'ajouter aux groupes vérifiés
            if not is_subset:
                verified_groups.append(group)
        return verified_groups # renvoie tous les groupes de tâches

#----------------------------------------------------------------
    def run(self):
        groups = []
        n = len(self.listTask)
        for i in range(n): # Permet le parcours de la liste de tâche à partir de i
            for j in range(i+1, n): # Permet le parcours de la liste de tâche à partir de i+1
                task1 = self.listTask[i]
                task2 = self.listTask[j]
                if self.checkBernstein(task1, task2): # Vérifier qu'il n'y a pas de dépendances
                    new_group = [task1.name, task2.name] # Crée un nouveau groupe avec les deux tâches
                    for k in range(j+1, n):
                        task3 = self.listTask[k]
                        # Vérifier si la troisième tâche peut être ajoutée au groupe existant
                        if all(self.checkBernstein(self.listTask[index], task3) for index in range(len(new_group))):
                            new_group.append(task3.name)
                    # Ajouter le groupe à la liste des groupes
                    groups.append(new_group)
                    
        # Groupes vérifiés => pas de groupes dupliqués ou de groupes sous-groupes d'autres
        verified_groups = self.verifyGroups(groups)

        # Affichage des groupes de tâches parallèles
        print("Groupes de tâches parallèles:")
        for i, group in enumerate(verified_groups, 1):
            print(f"Groupe {i}: {group}")

        # Exécuter les tâches en parallèle selon les conditions spécifiées
        if len(verified_groups) == 1: # Un seul groupe => on exécute les tâches en parallèle
            chosen_group = verified_groups[0]
        elif len(verified_groups) > 1: # plusieurs groupes => on en choisit un au hasard et on execute ses tâches en parallèle
            chosen_group = random.choice(verified_groups)
        else: # Toutes les tâches doivent être exécutées en séquentiel
            print("Impossible de trouver des tâches pouvant être exécutées simultanément.")
            return False

        threads = []

        # Exécuter les tâches du groupe choisi en parallèle
        print("\nExécution des tâches en parallèle:")
        for task_name in chosen_group:
            task = next(task for task in self.listTask if task.name == task_name)
            thread = threading.Thread(target=self.executedTask, args=(task,))
            threads.append(thread)
            thread.start() # lancer le thread

        for thread in threads:
            thread.join()

        return any(thread.is_alive() == False for thread in threads)
        
#----------------------------------------------------------------
    def executedTask(self, task): # lance l'exécution d'une tâche
        task.run()
        print(f"La tâche '{task.name}' est exécutée")
          
#----------------------------------------------------------------
    def rightEntry(self):
        # vérifier que le nom de tâche n'est pas déjà utilisé
        taskNames = set()
        for task in self.listTask:
            if task.name in taskNames: # le nom existe déjà
                print(f"Erreur: Le nom de tâche '{task.name}' existe déjà")
                return False
            taskNames.add(task.name) # on ajoute le nom déjà "rencontré" à la liste des noms de tâche
                
        # vérifier que la tâche dans getDependencies existe réellement        
        for dependencies in self.previousTask.values():
            for dep in dependencies:
                if dep not in taskNames:
                    print(f"Erreur: La tâche '{dep}' dans les dépendances n'existe pas.")
                    return False
                else:
                    print(f"'{dep}' existe bel et bien")
                    break
        
        # Autres vérifications pour le déterminisme
        for task in self.listTask:
            # Vérification des tâches sans domaine d'écriture
            if not task.writes:
                print(f"Attention: La tâche '{task.name}' n'écrit sur aucun domaine.")

            # Vérification des conditions de Bernstein
            for other_task in self.listTask:
                if task != other_task:
                    if not self.checkBernstein(task, other_task):
                        print(f"Attention: La condition de Bernstein n'est pas satisfaite entre les tâches '{task.name}' et '{other_task.name}'.")

        print("Les entrées ont bien été vérifiées")
        return True
        
#----------------------------------------------------------------
    def draw(self):
        self.run()
        
        # Création d'un graphe orienté
        G = nx.DiGraph()
        
        # Ajouter les tâches en tant que nœuds
        for task in self.listTask:
            G.add_node(task.name)

        # Ajouter les arêtes en fonction du parallélisme maximal
        for i, task1 in enumerate(self.listTask):
            for task2 in self.listTask[i+1:]:
                if not self.checkBernstein(task1, task2):
                    G.add_edge(task1.name, task2.name)
        
        # Suppression des arêtes redondantes
        areteSuppr = []
        for task1, task2 in G.edges():
            chemins = list(nx.all_simple_paths(G, source=task1, target=task2))
            if len(chemins) > 1:
                areteSuppr.append((task1, task2))
        G.remove_edges_from(areteSuppr)

        # Calculer la disposition des nœuds
        pos = nx.spring_layout(G, k=0.2)
        
        # Dessiner le graphe
        figure_name = f"Figure {TaskSystem.compteur}"
        plt.figure(figure_name, figsize=(10, 8))
        nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=1000, font_size=10, font_weight='bold', arrowsize=16, arrows=True)
        
        # Ajouter un titre
        plt.title(figure_name)
        
        # Afficher le graphe
        plt.show()
            
        # Incrémenter le compteur de figure
        TaskSystem.compteur += 1

#---------------------------------------------------------------
    def detTestRnd(self):
        """
        Méthode pour tester le déterminisme en exécutant deux fois le système avec les mêmes valeurs aléatoires.
        """
        if not self.run():
            print("Le système est déterministe.")
            return False
        else:
            # Obtenir les noms des variables des tâches exécutées en parallèle
            global_vars_names = set()

            for task in self.listTask:
                global_vars_names.update(task.writes)

            global_vars_names = list(global_vars_names)

            # Générer des valeurs aléatoires pour les variables globales
            random_values = [random.randint(0, 10) for _ in range(len(global_vars_names))]

            # Réinitialiser les variables globales avec les valeurs aléatoires générées
            for var_name, var_value in zip(global_vars_names, random_values):
                globals()[var_name] = var_value
            # Exécuter le système de tâches pour la première fois
            print("Première exécution du système :")
            self.run()
            # Réinitialiser les variables globales avec les mêmes valeurs aléatoires pour la deuxième exécution
            for var_name, var_value in zip(global_vars_names, random_values):
                globals()[var_name] = var_value
            executed_tasks = [task.name for task in self.listTask if task.executed_parallel]
            for task in self.listTask:
                if task.name not in executed_tasks:
                    task.run()
                    for var_name in task.writes:
                        var_name = globals()[var_name]
            result_1 = [globals()[var_name] for var_name in global_vars_names]
            print("Résultat de la première exécution :", end=" ")
            for var_name, var_value in zip(global_vars_names, result_1):
                print(f"{var_name} =", var_value, ",", end=" ")
            print("Fin de la première exécution\n")

            # Exécuter le système de tâches pour la deuxième fois
            print("Deuxième exécution du système :")
            self.run()  # Pas besoin d'appeler self.run() ici
            # Réinitialiser les variables globales avec les mêmes valeurs aléatoires pour la deuxième exécution
            for var_name, var_value in zip(global_vars_names, random_values):
                globals()[var_name] = var_value
            executed_tasks = [task.name for task in self.listTask if task.executed_parallel]
            for task in self.listTask:
                if task.name not in executed_tasks:
                    task.run()
                    for var_name in task.writes:
                        var_name = globals()[var_name]
            print("Résultat de la deuxième exécution :", end=" ")
            result_2 = [globals()[var_name] for var_name in global_vars_names]
            for var_name, var_value in zip(global_vars_names, result_2):
                print(f"{var_name} =", var_value, ",", end=" ")
            print("Fin de la deuxième exécution")

            # Vérifier si les résultats de la première et de la deuxième exécution sont les mêmes
            if result_1 == result_2:
                print("Le système est déterministe.")
            else:
                print("Le système n'est pas déterministe.")
    
#---------------------------------------------------------------
    def parCost(self):
        tempsRun = 0
        tempsRunSeq = 0
        for i in range(10): # faire 10 fois
            deb = time.time() # temps avant l'execution de run()
            self.run()
            fin = time.time() # temps après l'execution de run()
            tempsRun = tempsRun + (fin-deb) # temps d'execution de run()
            # On répète l'opération avec runSeq :
            deb2 = time.time()
            self.runSeq()
            fin2 = time.time()
            tempsRunSeq = tempsRunSeq + (fin2-deb2)
        tempsRun = tempsRun/i # moyenne des temps d'execution
        tempsRunSeq = tempsRunSeq/i
        # affichages
        print("Fonction parCost() :")
        print(f"run() : {tempsRun} secondes")
        print(f"runSeq() : {tempsRunSeq} secondes")
        # comparaison des temps d'exécution des deux fonctions
        if(tempsRun>tempsRunSeq):
            print(f"différence : '{tempsRun - tempsRunSeq}' secondes")
        else:
            print(f"différence : '{tempsRunSeq - tempsRun}' secondes")
        
  #---------------------------------------------------------------  
